<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Chess Game</title>
    <audio id="moveSound" src="sounds/move.mp3" preload="auto"></audio>
    <audio id="captureSound" src="sounds/capture.mp3" preload="auto"></audio>
    <audio id="checkSound" src="sounds/check.mp3" preload="auto"></audio>
    <audio id="castleSound" src="sounds/castle.mp3" preload="auto"></audio>
    <audio
      id="checkmateSound"
      src="sounds/checkmate.mp3"
      preload="auto"
    ></audio>
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 10px;
        background: #eee;
        user-select: none;
      }
      #game {
        display: flex;
        gap: 10px;
        justify-content: center;
        align-items: flex-start;
      }
      #capturedWhite,
      #capturedBlack {
        width: 80px;
        min-height: 320px;
        background: linear-gradient(160deg, #f8f8f8 60%, #e2e2e2 100%);
        border: 2px solid #b58863;
        border-radius: 16px;
        box-shadow: 0 4px 16px #0001, 0 1px 0 #fff8 inset;
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        grid-auto-rows: 40px;
        align-content: start;
        padding: 10px 6px;
        gap: 8px;
        margin: 100px 4px 0;
      }

      #capturedWhite {
        border-top: 4px solid #a67c52;
        border-bottom: 4px solid #e2c08d;
      }

      #capturedBlack {
        border-top: 4px solid #a67c52;
        border-bottom: 4px solid #e2c08d;
      }

      #capturedWhite img,
      #capturedBlack img {
        width: 32px;
        height: 32px;
        object-fit: contain;
        justify-self: center;
        align-self: center;
        filter: drop-shadow(0 2px 4px #b5886333);
        background: #fff;
        border-radius: 8px;
        padding: 2px;
        box-shadow: 0 1px 4px #0001;
        transition: transform 0.15s;
      }

      #capturedWhite img:hover,
      #capturedBlack img:hover {
        transform: scale(1.08);
        box-shadow: 0 2px 8px #ffe06688;
      }
      #board {
        display: grid;
        grid-template-columns: repeat(8, 60px);
        grid-template-rows: repeat(8, 60px);
        border: 8px solid #a67c52;
        box-shadow: 0 24px 48px 0 #0007, 0 2px 0 #fff8 inset,
          0 0 0 18px #e2c08d inset, 0 0 0 32px #a67c52 inset;
        background: linear-gradient(160deg, #e2c08d 0%, #fffbe6 100%);
        border-radius: 28px;
        padding: 22px;
        position: relative;
        perspective: 900px;
        transform: rotateX(10deg);
      }
      .square {
        width: 60px;
        height: 60px;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 44px;
        cursor: pointer;
        position: relative;
        box-shadow: 0 4px 16px #0002, 0 2px 8px #fff4 inset,
          0 1.5px 0 #fff4 inset, 0 0.5px 2px #0003;
        border-radius: 12px;
        transition: box-shadow 0.2s, transform 0.2s;
        overflow: hidden;
        z-index: 1;
      }
      .square img {
        filter: drop-shadow(0 6px 12px #0005);
        transition: transform 0.15s, box-shadow 0.15s;
        z-index: 2;
      }
      .square img.player-turn-hover:hover {
        transform: scale(1.08);
        box-shadow: 0 2px 8px #ffe06688;
      }
      .square:active img {
        transform: scale(0.93);
      }
      .light {
        background: linear-gradient(120deg, #fffbe6 80%, #f7e7c4 100%);
        box-shadow: 0 2px 8px #fff8 inset, 0 0.5px 2px #0001;
        position: relative;
      }
      .light::before {
        content: "";
        position: absolute;
        top: 2px;
        left: 2px;
        right: 2px;
        bottom: 2px;
        border-radius: 10px;
        background: linear-gradient(120deg, #fff8 0%, #fff0 80%);
        opacity: 0.8;
        pointer-events: none;
        z-index: 0;
      }
      .dark {
        background: linear-gradient(120deg, #e2c08d 80%, #a67c52 100%);
        box-shadow: 0 2px 8px #0004 inset, 0 0.5px 2px #fff1;
        position: relative;
      }
      .dark::before {
        content: "";
        position: absolute;
        top: 2px;
        left: 2px;
        right: 2px;
        bottom: 2px;
        border-radius: 10px;
        background: linear-gradient(120deg, #fff2 0%, #0003 100%);
        opacity: 0.25;
        pointer-events: none;
        z-index: 0;
      }
      .square.highlight {
        outline: 3px solid #ffe066;
        box-shadow: 0 0 18px 4px #ffe06688, 0 2px 8px #0002 inset;
        z-index: 2;
      }
      #checkText {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: red;
        font-weight: bold;
        font-size: 48px;
        opacity: 0;
        pointer-events: none;
        user-select: none;
        transition: opacity 0.3s ease-in-out;
        z-index: 1000;
        text-shadow: 0 0 10px red;
      }
      #checkText.show {
        opacity: 1;
        animation: pulse 1.5s ease-in-out 3;
      }
      @keyframes pulse {
        0%,
        100% {
          text-shadow: 0 0 10px red;
        }
        50% {
          text-shadow: 0 0 25px orange;
        }
      }
      #promotionOverlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.7);
        display: none;
        justify-content: center;
        align-items: center;
        gap: 20px;
        z-index: 2000;
      }
      #promotionOverlay img {
        width: 60px;
        height: 60px;
        cursor: pointer;
        border: 2px solid white;
        border-radius: 6px;
        background: white;
      }
      #gameOverOverlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.8);
        display: none;
        justify-content: center;
        align-items: center;
        flex-direction: column;
        color: white;
        font-size: 32px;
        z-index: 3000;
      }
      #gameOverOverlay button {
        margin-top: 20px;
        font-size: 18px;
        padding: 10px 20px;
        cursor: pointer;
      }
      .square img.player-turn-hover:hover {
        /* transform: scale(1.13) rotate(-6deg); */
        box-shadow: 0 6px 24px #ffe066cc, 0 2px 8px #b5886333;
        background: #fffbe6;
        border-radius: 12px;
        z-index: 3;
        transition: transform 0.18s cubic-bezier(0.4, 1.4, 0.6, 1),
          box-shadow 0.18s, background 0.18s;
      }
      .possible-move {
        position: relative;
      }
      .possible-move:not(.capture-highlight)::after {
        content: "";
        position: absolute;
        top: 50%;
        left: 50%;
        width: 18px;
        height: 18px;
        background: rgba(40, 40, 40, 0.22);
        border-radius: 50%;
        transform: translate(-50%, -50%);
        z-index: 5;
        pointer-events: none;
      }
      .capture-highlight {
        position: relative;
        z-index: 100 !important;
        box-shadow: 0 0 0 5px #e74c3cdd, 0 4px 16px #0002, 0 2px 8px #fff4 inset !important;
      }
      .last-move {
        position: relative;
        z-index: 1;
      }
      .last-move::after {
        content: "";
        position: absolute;
        inset: 0;
        border-radius: 10px;
        pointer-events: none;
        z-index: 1;
        background: #ffe06655;
        box-shadow: 0 0 0 2px #ffe066cc;
        opacity: 1;
        transition: background 0.2s, box-shadow 0.2s;
      }
      #undoBtn,
      #redoBtn {
        background: linear-gradient(120deg, #fffbe6 60%, #e2c08d 100%);
        color: #7a5c2e;
        border: 2px solid #b58863;
        border-radius: 8px;
        padding: 8px 22px;
        font-size: 18px;
        font-family: inherit;
        font-weight: bold;
        margin: 0 8px;
        box-shadow: 0 2px 8px #b5886322, 0 1px 0 #fff8 inset;
        cursor: pointer;
        transition: background 0.18s, box-shadow 0.18s, transform 0.13s;
      }
      #undoBtn:hover,
      #redoBtn:hover {
        background: linear-gradient(120deg, #f0df98 70%, #bb9761 100%);
        /* color: #a67c52; */
        color: #af6010;
        box-shadow: 0 4px 16px #ffe06655, 0 2px 8px #fff8 inset;
        transform: translateY(-2px) scale(1.04);
      }
      @keyframes lastMovePulse {
        0% {
          box-shadow: 0 0 0 0 #ffe066cc, 0 0 0 0 #ffe06644 inset;
          background: linear-gradient(120deg, #ffe066cc 60%, #fffbe6 100%);
          outline-color: #ffe066cc;
        }
        40% {
          box-shadow: 0 0 0 18px #ffe06655, 0 0 0 12px #ffe06644 inset;
          background: linear-gradient(120deg, #ffe066 60%, #fffbe6 100%);
          outline-color: #ffe066;
        }
        100% {
          box-shadow: 0 0 0 8px #ffe06655, 0 0 16px 4px #ffe06644 inset,
            0 2px 8px #fff8 inset;
          background: linear-gradient(120deg, #fffbe6 60%, #ffe06699 100%);
          outline-color: #ffe066cc;
        }
      }
      @media (max-width: 700px) {
        #game {
          flex-direction: column;
          align-items: center;
          gap: 0;
          width: 100vw;
          margin: 0;
        }
        #capturedWhite,
        #capturedBlack {
          width: 98vw !important;
          max-width: 98vw !important;
          min-height: 0;
          height: 50px;
          margin: 0 auto 6px auto !important;
          grid-template-columns: repeat(8, 1fr);
          grid-auto-rows: 20px;
          padding: 2px 1px;
          border-radius: 8px;
          box-sizing: border-box;
        }
        #capturedWhite {
          order: 1;
          margin-top: 15px !important;
          margin-bottom: 0 !important;
        }
        #board {
          order: 2;
          margin: 0 auto !important;
          padding: 0 !important;
          border-width: 2vw !important;
          border-radius: 6vw !important;
          grid-template-columns: repeat(8, 1fr) !important;
          grid-template-rows: repeat(8, 1fr) !important;
          width: 98vw !important;
          height: 98vw !important;
          max-width: 98vw !important;
          max-height: 98vw !important;
          min-width: 0 !important;
          min-height: 0 !important;
          box-sizing: border-box;
          display: grid !important;
        }
        .square {
          width: 100% !important;
          height: 100% !important;
          aspect-ratio: 1 / 1;
          font-size: 12px !important;
          border-radius: 3vw !important;
          box-sizing: border-box;
          padding: 0 !important;
        }
        .square img {
          min-width: 12px !important;
          min-height: 12px !important;
          width: 90% !important;
          height: 90% !important;
          max-width: 100% !important;
          max-height: 100% !important;
          object-fit: contain !important;
          position: relative;
          z-index: 2;
        }
        #capturedBlack {
          order: 3;
          margin-bottom: 8px !important;
          margin-top: 0 !important;
        }
        /* Move undo/redo buttons to the bottom */
        #undoBtn,
        #redoBtn {
          width: 44vw !important;
          max-width: 180px !important;
          margin: 8px 2vw !important;
          font-size: 16px !important;
          padding: 8px 0 !important;
        }
        /* Center the undo/redo button container at the bottom */
        div[style*="margin-bottom: 10px"] {
          order: 4;
          display: flex !important;
          justify-content: center !important;
          margin: 10px 0 0 0 !important;
          width: 100vw !important;
          gap: 0 !important;
        }
        /* Center the settings button at the top */
        div[style*="text-align: center; margin-bottom: 10px"]:first-child {
          order: 0;
          margin-bottom: 8px !important;
          width: 100vw !important;
          display: flex !important;
          justify-content: center !important;
        }
        h1 {
          font-size: 6vw !important;
          margin: 10px 0 0 0 !important;
        }
        #capturedWhite,
        #capturedBlack {
          display: flex !important;
          justify-content: start !important;
          align-items: center !important;
          flex-wrap: wrap !important;
          gap: 2px !important;
          padding: 0px 5px;
          /* Remove grid for mobile, use flex for centering */
        }
        #capturedWhite img,
        #capturedBlack img {
          margin: 4px 2px !important;
          width: 28px !important;
          height: 28px !important;
          object-fit: contain !important;
          display: inline-block !important;
        }
      }
    </style>
  </head>
  <body>
    <h1 style="text-align: center">Chess Game</h1>
    <div style="text-align: center; margin-bottom: 10px">
      <button
        id="settingsBtn"
        style="
          font-size: 18px;
          border-radius: 8px;
          padding: 8px 18px;
          background: linear-gradient(120deg, #fffbe6 60%, #e2c08d 100%);
          border: 2px solid #b58863;
          color: #7a5c2e;
          font-weight: bold;
          cursor: pointer;
          box-shadow: 0 2px 8px #b5886322, 0 1px 0 #fff8 inset;
        "
      >
        ⚙️ Settings
      </button>
    </div>
    <div
      id="settingsOverlay"
      style="
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.5);
        z-index: 4000;
        justify-content: center;
        align-items: center;
      "
    >
      <div
        style="
          background: #fffbe6;
          border-radius: 18px;
          padding: 36px 32px 28px 32px;
          box-shadow: 0 8px 32px #0004;
          min-width: 260px;
          display: flex;
          flex-direction: column;
          align-items: center;
          position: relative;
        "
      >
        <button
          id="closeSettingsBtn"
          style="
            position: absolute;
            top: 10px;
            right: 14px;
            background: none;
            border: none;
            font-size: 22px;
            cursor: pointer;
            color: #a67c52;
          "
        >
          ✖️
        </button>
        <h2 style="margin-bottom: 18px; color: #a67c52">Settings</h2>
        <button
          id="restartFromSettings"
          style="
            margin-bottom: 14px;
            font-size: 18px;
            border-radius: 8px;
            padding: 8px 22px;
            background: linear-gradient(120deg, #ffe066 70%, #e2c08d 100%);
            border: 2px solid #b58863;
            color: #a67c52;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 2px 8px #b5886322, 0 1px 0 #fff8 inset;
          "
        >
          Restart Game
        </button>
        <button
          id="resumeBtn"
          style="
            font-size: 18px;
            border-radius: 8px;
            padding: 8px 22px;
            background: linear-gradient(120deg, #fffbe6 60%, #e2c08d 100%);
            border: 2px solid #b58863;
            color: #7a5c2e;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 2px 8px #b5886322, 0 1px 0 #fff8 inset;
          "
        >
          Resume
        </button>
        <button
          id="localBtn"
          style="
            margin-top: 18px;
            font-size: 18px;
            border-radius: 8px;
            padding: 8px 22px;
            background: linear-gradient(120deg, #e2c08d 60%, #fffbe6 100%);
            border: 2px solid #b58863;
            color: #7a5c2e;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 2px 8px #b5886322, 0 1px 0 #fff8 inset;
          "
        >
          Local
        </button>
        <button
          id="computerBtn"
          style="
            margin-top: 10px;
            font-size: 18px;
            border-radius: 8px;
            padding: 8px 22px;
            background: linear-gradient(120deg, #e2c08d 60%, #fffbe6 100%);
            border: 2px solid #b58863;
            color: #7a5c2e;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 2px 8px #b5886322, 0 1px 0 #fff8 inset;
          "
        >
          Computer
        </button>
      </div>
    </div>
    <div style="text-align: center; margin-bottom: 10px">
      <button id="undoBtn">Undo</button>
      <button id="redoBtn">Redo</button>
    </div>
    <div id="game">
      <div id="capturedWhite" title="White Captured Pieces"></div>
      <div id="board"></div>
      <div id="capturedBlack" title="Black Captured Pieces"></div>
    </div>

    <div id="checkText">Check!</div>

    <div id="promotionOverlay"></div>

    <div id="gameOverOverlay">
      <div id="gameOverMessage"></div>
      <button id="restartBtn">Restart Game</button>
    </div>

    <script>
      let boardState = [];
      let turn = "w";
      let selected = null;
      let captured = { w: [], b: [] };
      let history = [];
      let future = [];
      let lastMove = null;
      let enPassantTarget = null;

      // Track if king/rooks have moved
      let kingMoved = { w: false, b: false };
      let rookMoved = { w: { k: false, q: false }, b: { k: false, q: false } };

      const boardElem = document.getElementById("board");
      const capturedWhiteElem = document.getElementById("capturedWhite");
      const capturedBlackElem = document.getElementById("capturedBlack");
      const checkText = document.getElementById("checkText");
      const promotionOverlay = document.getElementById("promotionOverlay");
      const gameOverOverlay = document.getElementById("gameOverOverlay");
      const gameOverMessage = document.getElementById("gameOverMessage");
      const restartBtn = document.getElementById("restartBtn");
      const moveSound = document.getElementById("moveSound");
      const captureSound = document.getElementById("captureSound");
      const checkSound = document.getElementById("checkSound");
      const checkmateSound = document.getElementById("checkmateSound");
      const castleSound = document.getElementById("castleSound");

      const settingsBtn = document.getElementById("settingsBtn");
      const settingsOverlay = document.getElementById("settingsOverlay");
      const closeSettingsBtn = document.getElementById("closeSettingsBtn");
      const restartFromSettings = document.getElementById(
        "restartFromSettings"
      );
      const resumeBtn = document.getElementById("resumeBtn");

      // Add these lines after your other DOM queries
      const localBtn = document.getElementById("localBtn");
      const computerBtn = document.getElementById("computerBtn");

      // Example event handlers (customize as needed)
      computerBtn.onclick = () => {
        window.gameMode = "computer";
        settingsOverlay.style.display = "none";
        // If it's black's turn (bot), let the bot move immediately
        makeAIMoveIfNeeded();
      };
      localBtn.onclick = () => {
        window.gameMode = "local";
        settingsOverlay.style.display = "none";
      };

      // Show settings overlay
      settingsBtn.onclick = () => {
        settingsOverlay.style.display = "flex";
      };
      // Hide settings overlay
      closeSettingsBtn.onclick = () => {
        settingsOverlay.style.display = "none";
      };
      resumeBtn.onclick = () => {
        settingsOverlay.style.display = "none";
      };
      // Restart from settings
      restartFromSettings.onclick = () => {
        castleSound.currentTime = 0;
        castleSound.play();
        settingsOverlay.style.display = "none";
        initializeBoard();
      };

      function initializeBoard() {
        boardState = [
          ["br", "bn", "bb", "bq", "bk", "bb", "bn", "br"],
          ["bp", "bp", "bp", "bp", "bp", "bp", "bp", "bp"],
          ["", "", "", "", "", "", "", ""],
          ["", "", "", "", "", "", "", ""],
          ["", "", "", "", "", "", "", ""],
          ["", "", "", "", "", "", "", ""],
          ["wp", "wp", "wp", "wp", "wp", "wp", "wp", "wp"],
          ["wr", "wn", "wb", "wq", "wk", "wb", "wn", "wr"],
        ];
        turn = "w";
        selected = null;
        captured = { w: [], b: [] };
        history = [];
        future = [];
        kingMoved = { w: false, b: false };
        rookMoved = { w: { k: false, q: false }, b: { k: false, q: false } };
        enPassantTarget = null; // Reset en passant
        renderBoard();
        renderCaptured();
        gameOverOverlay.style.display = "none";
        if (typeof makeAIMoveIfNeeded === "function") makeAIMoveIfNeeded();
      }

      function renderBoard() {
        boardElem.innerHTML = "";
        let possibleMoves = [];
        if (selected) {
          possibleMoves = getLegalMoves(selected.row, selected.col);
        }
        for (let r = 0; r < 8; r++) {
          for (let c = 0; c < 8; c++) {
            const sq = document.createElement("div");
            sq.classList.add("square");
            sq.classList.add((r + c) % 2 === 0 ? "light" : "dark");
            sq.dataset.row = r;
            sq.dataset.col = c;

            // Highlight last move
            if (
              lastMove &&
              ((lastMove.from[0] === r && lastMove.from[1] === c) ||
                (lastMove.to[0] === r && lastMove.to[1] === c))
            ) {
              sq.classList.add("last-move");
            }

            const piece = boardState[r][c];
            if (piece) {
              const img = document.createElement("img");
              img.src = `images/${piece}.png`;
              img.alt = piece;
              img.draggable = false;
              img.style.userSelect = "none";
              img.style.width = "48px";
              img.style.height = "48px";
              if (piece[0] === turn) img.classList.add("player-turn-hover");
              sq.appendChild(img);
            }

            if (selected && selected.row === r && selected.col === c) {
              sq.classList.add("highlight");
            }

            // Highlight possible moves
            if (selected) {
              for (const [mr, mc] of possibleMoves) {
                if (mr === r && mc === c) {
                  if (boardState[r][c] && boardState[r][c][0] !== turn) {
                    sq.classList.add("capture-highlight");
                  } else if (!boardState[r][c]) {
                    sq.classList.add("possible-move");
                  }
                }
              }
            }

            sq.addEventListener("click", () => onSquareClick(r, c));
            boardElem.appendChild(sq);
          }
        }
      }

      function renderCaptured() {
        capturedWhiteElem.innerHTML = "";
        capturedBlackElem.innerHTML = "";
        captured.w.forEach((p) => {
          const img = document.createElement("img");
          img.src = `images/${p}.png`;
          img.style.width = "32px";
          img.style.height = "32px";
          capturedWhiteElem.appendChild(img);
        });
        captured.b.forEach((p) => {
          const img = document.createElement("img");
          img.src = `images/${p}.png`;
          img.style.width = "32px";
          img.style.height = "32px";
          capturedBlackElem.appendChild(img);
        });
      }

      function onSquareClick(r, c) {
        if (gameOverOverlay.style.display === "flex") return;

        const piece = boardState[r][c];

        if (selected) {
          const moves = getLegalMoves(selected.row, selected.col);
          const canMove = moves.some((m) => m[0] === r && m[1] === c);
          if (canMove) {
            // Play capture or move sound
            if (boardState[r][c] && boardState[r][c][0] !== turn) {
              captureSound.currentTime = 0;
              captureSound.play();
            } else {
              moveSound.currentTime = 0;
              moveSound.play();
            }
            makeMove(selected.row, selected.col, r, c);
            selected = null;
            renderBoard();
          } else {
            if (selected.row === r && selected.col === c) {
              selected = null;
              renderBoard();
              return;
            }
            if (piece && piece[0] === turn) {
              moveSound.currentTime = 0;
              moveSound.play();
              selected = { row: r, col: c };
              renderBoard();
            }
          }
        } else {
          if (piece && piece[0] === turn) {
            moveSound.currentTime = 0;
            moveSound.play();
            selected = { row: r, col: c };
            renderBoard();
          }
        }
      }

      function makeMove(fr, fc, tr, tc, special) {
        // Save current state for undo
        history.push({
          board: JSON.parse(JSON.stringify(boardState)),
          turn,
          captured: JSON.parse(JSON.stringify(captured)),
          selected: selected ? { ...selected } : null,
          kingMoved: JSON.parse(JSON.stringify(kingMoved)),
          rookMoved: JSON.parse(JSON.stringify(rookMoved)),
          lastMove: lastMove ? { ...lastMove } : null,
          enPassantTarget: enPassantTarget ? { ...enPassantTarget } : null,
        });
        future = []; // Clear redo stack on new move

        const movingPiece = boardState[fr][fc];
        const targetPiece = boardState[tr][tc];

        // --- En Passant capture ---
        if (
          movingPiece &&
          movingPiece[1] === "p" &&
          enPassantTarget &&
          tr === enPassantTarget.row &&
          tc === enPassantTarget.col
        ) {
          // Remove the captured pawn
          const capRow = turn === "w" ? tr + 1 : tr - 1;
          captured[turn].push(boardState[capRow][tc]);
          boardState[capRow][tc] = "";
        }

        // --- Castling move ---
        if (movingPiece && movingPiece[1] === "k" && Math.abs(tc - fc) === 2) {
          // King-side
          if (tc === 6) {
            boardState[tr][5] = boardState[tr][7];
            boardState[tr][7] = "";
            castleSound.currentTime = 0;
            castleSound.play();
          }
          // Queen-side
          if (tc === 2) {
            boardState[tr][3] = boardState[tr][0];
            boardState[tr][0] = "";
            castleSound.currentTime = 0;
            castleSound.play();
          }
          kingMoved[turn] = true;
          if (tc === 6) rookMoved[turn].k = true;
          if (tc === 2) rookMoved[turn].q = true;
        }

        // Update king/rook moved state
        if (movingPiece === turn + "k") kingMoved[turn] = true;
        if (
          movingPiece === turn + "r" &&
          fr === (turn === "w" ? 7 : 0) &&
          fc === 0
        )
          rookMoved[turn].q = true;
        if (
          movingPiece === turn + "r" &&
          fr === (turn === "w" ? 7 : 0) &&
          fc === 7
        )
          rookMoved[turn].k = true;

        if (targetPiece) {
          captured[turn].push(targetPiece);
        }
        boardState[tr][tc] = movingPiece;
        boardState[fr][fc] = "";

        lastMove = { from: [fr, fc], to: [tr, tc] };

        // --- En Passant target update ---
        if (movingPiece && movingPiece[1] === "p" && Math.abs(tr - fr) === 2) {
          // Set en passant target square
          enPassantTarget = {
            row: (fr + tr) / 2,
            col: fc,
            color: turn,
          };
        } else {
          enPassantTarget = null;
        }

        if (
          (movingPiece === "wp" && tr === 0) ||
          (movingPiece === "bp" && tr === 7)
        ) {
          showPromotionMenu(tr, tc, turn);
          return;
        }

        renderCaptured();
        renderBoard();

        const opponent = turn === "w" ? "b" : "w";

        if (isCheck(opponent)) {
          showCheckText();
          if (isCheckmate(opponent)) {
            checkmateSound.currentTime = 0;
            checkmateSound.play();
            gameOverMessage.textContent =
              (turn === "w" ? "White" : "Black") + " wins by checkmate!";
            gameOverOverlay.style.display = "flex";
            return;
          }
        }
        if (isKingCaptured(opponent)) {
          checkmateSound.currentTime = 0;
          checkmateSound.play();
          gameOverMessage.textContent =
            (turn === "w" ? "White" : "Black") + " wins! King captured.";
          gameOverOverlay.style.display = "flex";
          return;
        }

        // --- Stalemate check ---
        if (isStalemate(opponent)) {
          gameOverMessage.textContent = "Draw by stalemate!";
          gameOverOverlay.style.display = "flex";
          return;
        }

        // --- Insufficient material check ---
        if (isInsufficientMaterial()) {
          gameOverMessage.textContent = "Draw by insufficient material!";
          gameOverOverlay.style.display = "flex";
          return;
        }

        turn = opponent;
        if (typeof makeAIMoveIfNeeded === "function") makeAIMoveIfNeeded();
      }

      function showPromotionMenu(row, col, color) {
        promotionOverlay.innerHTML = "";
        promotionOverlay.style.display = "flex";
        ["q", "r", "b", "n"].forEach((p) => {
          const img = document.createElement("img");
          img.src = `images/${color}${p}.png`;
          img.alt = p.toUpperCase();
          img.title = `Promote to ${p.toUpperCase()}`;
          img.addEventListener("click", () => {
            boardState[row][col] = color + p;
            promotionOverlay.style.display = "none";
            renderCaptured();
            renderBoard();

            const opponent = color === "w" ? "b" : "w";

            if (isCheck(opponent)) {
              showCheckText();
              if (isCheckmate(opponent)) {
                gameOverMessage.textContent =
                  (color === "w" ? "White" : "Black") + " wins by checkmate!";
                gameOverOverlay.style.display = "flex";
                return;
              }
            }
            turn = opponent;
          });
          promotionOverlay.appendChild(img);
        });
      }

      restartBtn.addEventListener("click", () => {
        castleSound.currentTime = 0;
        castleSound.play();
        initializeBoard();
      });

      function showCheckText() {
        checkSound.currentTime = 0;
        checkSound.play();
        checkText.classList.add("show");
        setTimeout(() => {
          checkText.classList.remove("show");
        }, 2000);
      }

      function isKingCaptured(color) {
        for (let r = 0; r < 8; r++) {
          for (let c = 0; c < 8; c++) {
            if (boardState[r][c] === color + "k") return false;
          }
        }
        return true;
      }

      // Check if color is in check
      function isCheck(color) {
        const kingPos = findKing(color);
        if (!kingPos) return true; // King missing means checkmate or game over
        const opponent = color === "w" ? "b" : "w";
        for (let r = 0; r < 8; r++) {
          for (let c = 0; c < 8; c++) {
            if (boardState[r][c].startsWith(opponent)) {
              const moves = getRawMoves(r, c, true);
              if (
                moves.some((m) => m[0] === kingPos.row && m[1] === kingPos.col)
              )
                return true;
            }
          }
        }
        return false;
      }

      // Check if checkmate (no legal moves to escape)
      function isCheckmate(color) {
        for (let r = 0; r < 8; r++) {
          for (let c = 0; c < 8; c++) {
            if (boardState[r][c].startsWith(color)) {
              const moves = getLegalMoves(r, c);
              if (moves.length > 0) return false;
            }
          }
        }
        return true;
      }

      // Add this function below isCheckmate
      function isStalemate(color) {
        if (isCheck(color)) return false;
        for (let r = 0; r < 8; r++) {
          for (let c = 0; c < 8; c++) {
            if (
              boardState[r][c].startsWith &&
              boardState[r][c].startsWith(color)
            ) {
              const moves = getLegalMoves(r, c);
              if (moves.length > 0) return false;
            }
          }
        }
        return true;
      }

      // Check for draw by insufficient material
      function isInsufficientMaterial() {
        // Gather all pieces on the board
        const pieces = [];
        for (let r = 0; r < 8; r++) {
          for (let c = 0; c < 8; c++) {
            const p = boardState[r][c];
            if (p) pieces.push(p);
          }
        }
        // Only kings left
        if (pieces.length === 2) return true;
        // King + bishop/knight vs king
        if (pieces.length === 3) {
          const types = pieces.map((p) => p[1]);
          if (
            types.filter((t) => t === "k").length === 2 &&
            (types.includes("b") || types.includes("n"))
          ) {
            return true;
          }
        }
        // King + bishop vs king + bishop (both bishops on same color)
        if (pieces.length === 4) {
          const bishops = pieces.filter((p) => p[1] === "b");
          if (bishops.length === 2) {
            // Check if both bishops are on same color square
            const squares = [];
            for (let r = 0; r < 8; r++) {
              for (let c = 0; c < 8; c++) {
                if (boardState[r][c] && boardState[r][c][1] === "b") {
                  squares.push((r + c) % 2);
                }
              }
            }
            if (squares.length === 2 && squares[0] === squares[1]) {
              return true;
            }
          }
        }
        return false;
      }

      function findKing(color) {
        for (let r = 0; r < 8; r++) {
          for (let c = 0; c < 8; c++) {
            if (boardState[r][c] === color + "k") return { row: r, col: c };
          }
        }
        return null;
      }

      // Get legal moves filtered for checks
      function getLegalMoves(r, c) {
        const piece = boardState[r][c];
        if (!piece) return [];
        const color = piece[0];
        const rawMoves = getRawMoves(r, c, false);
        const legal = [];
        for (const [tr, tc] of rawMoves) {
          // simulate move
          const temp = boardState[tr][tc];
          boardState[tr][tc] = piece;
          boardState[r][c] = "";
          const inCheck = isCheck(color);
          boardState[r][c] = piece;
          boardState[tr][tc] = temp;
          if (!inCheck) legal.push([tr, tc]);
        }
        return legal;
      }

      // Get raw moves without checking for check, returns array of [r,c]
      function getRawMoves(r, c, ignorePins) {
        const moves = [];
        const piece = boardState[r][c];
        if (!piece) return moves;
        const color = piece[0];
        const type = piece[1];
        const enemy = color === "w" ? "b" : "w";

        const directions = {
          n: [
            [-2, -1],
            [-2, 1],
            [-1, -2],
            [-1, 2],
            [1, -2],
            [1, 2],
            [2, -1],
            [2, 1],
          ],
          b: [
            [-1, -1],
            [-1, 1],
            [1, -1],
            [1, 1],
          ],
          r: [
            [-1, 0],
            [1, 0],
            [0, -1],
            [0, 1],
          ],
          q: [
            [-1, -1],
            [-1, 1],
            [1, -1],
            [1, 1],
            [-1, 0],
            [1, 0],
            [0, -1],
            [0, 1],
          ],
          k: [
            [-1, -1],
            [-1, 0],
            [-1, 1],
            [0, -1],
            [0, 1],
            [1, -1],
            [1, 0],
            [1, 1],
          ],
        };

        function onBoard(x, y) {
          return x >= 0 && x < 8 && y >= 0 && y < 8;
        }

        if (type === "p") {
          let dir = color === "w" ? -1 : 1;
          // Move forward
          if (onBoard(r + dir, c) && !boardState[r + dir][c]) {
            moves.push([r + dir, c]);
            // First move double step
            if (
              ((color === "w" && r === 6) || (color === "b" && r === 1)) &&
              !boardState[r + 2 * dir][c]
            ) {
              moves.push([r + 2 * dir, c]);
            }
          }
          // Captures
          for (let dc of [-1, 1]) {
            let nr = r + dir,
              nc = c + dc;
            if (
              onBoard(nr, nc) &&
              boardState[nr][nc] &&
              boardState[nr][nc][0] === enemy
            ) {
              moves.push([nr, nc]);
            }
            // --- En Passant ---
            if (
              enPassantTarget &&
              enPassantTarget.row === nr &&
              enPassantTarget.col === nc &&
              boardState[r][nc] &&
              boardState[r][nc][0] === enemy &&
              boardState[r][nc][1] === "p"
            ) {
              moves.push([nr, nc]);
            }
          }
        } else if ("nbrkq".includes(type)) {
          if (type === "n") {
            for (let [dr, dc] of directions.n) {
              let nr = r + dr,
                nc = c + dc;
              if (
                onBoard(nr, nc) &&
                (!boardState[nr][nc] || boardState[nr][nc][0] === enemy)
              ) {
                moves.push([nr, nc]);
              }
            }
          } else if ("bqr".includes(type)) {
            const dirs = directions[type];
            for (let [dr, dc] of dirs) {
              let nr = r + dr,
                nc = c + dc;
              while (onBoard(nr, nc)) {
                if (!boardState[nr][nc]) {
                  moves.push([nr, nc]);
                } else {
                  if (boardState[nr][nc][0] === enemy) moves.push([nr, nc]);
                  break;
                }
                nr += dr;
                nc += dc;
              }
            }
          } else if (type === "k") {
            for (let [dr, dc] of directions.k) {
              let nr = r + dr,
                nc = c + dc;
              if (
                onBoard(nr, nc) &&
                (!boardState[nr][nc] || boardState[nr][nc][0] === enemy)
              ) {
                moves.push([nr, nc]);
              }
            }
            // --- Castling logic ---
            if (!ignorePins && !kingMoved[color] && !isCheck(color)) {
              // King-side
              if (
                !rookMoved[color].k &&
                !boardState[r][5] &&
                !boardState[r][6] &&
                !isSquareAttacked(r, 5, enemy) &&
                !isSquareAttacked(r, 6, enemy)
              ) {
                moves.push([r, 6, "castleK"]);
              }
              // Queen-side
              if (
                !rookMoved[color].q &&
                !boardState[r][1] &&
                !boardState[r][2] &&
                !boardState[r][3] &&
                !isSquareAttacked(r, 2, enemy) &&
                !isSquareAttacked(r, 3, enemy)
              ) {
                moves.push([r, 2, "castleQ"]);
              }
            }
          }
        }

        return moves;
      }

      // Helper for castling: is a square attacked by enemy?
      function isSquareAttacked(r, c, enemyColor) {
        for (let rr = 0; rr < 8; rr++) {
          for (let cc = 0; cc < 8; cc++) {
            if (boardState[rr][cc] && boardState[rr][cc][0] === enemyColor) {
              const moves = getRawMoves(rr, cc, true);
              if (moves.some((m) => m[0] === r && m[1] === c)) return true;
            }
          }
        }
        return false;
      }

      function undoMove() {
        if (history.length === 0) return;
        future.push({
          board: JSON.parse(JSON.stringify(boardState)),
          turn,
          captured: JSON.parse(JSON.stringify(captured)),
          selected: selected ? { ...selected } : null,
          kingMoved: JSON.parse(JSON.stringify(kingMoved)),
          rookMoved: JSON.parse(JSON.stringify(rookMoved)),
          lastMove: lastMove ? { ...lastMove } : null,
          enPassantTarget: enPassantTarget ? { ...enPassantTarget } : null,
        });
        const prev = history.pop();
        boardState = JSON.parse(JSON.stringify(prev.board));
        turn = prev.turn;
        captured = JSON.parse(JSON.stringify(prev.captured));
        selected = prev.selected ? { ...prev.selected } : null;
        kingMoved = JSON.parse(JSON.stringify(prev.kingMoved));
        rookMoved = JSON.parse(JSON.stringify(prev.rookMoved));
        lastMove = prev.lastMove || null;
        enPassantTarget = prev.enPassantTarget || null;
        renderCaptured();
        renderBoard();
        gameOverOverlay.style.display = "none";
      }

      function redoMove() {
        if (future.length === 0) return;
        history.push({
          board: JSON.parse(JSON.stringify(boardState)),
          turn,
          captured: JSON.parse(JSON.stringify(captured)),
          selected: selected ? { ...selected } : null,
          kingMoved: JSON.parse(JSON.stringify(kingMoved)),
          rookMoved: JSON.parse(JSON.stringify(rookMoved)),
          lastMove: lastMove ? { ...lastMove } : null,
          enPassantTarget: enPassantTarget ? { ...enPassantTarget } : null,
        });
        const next = future.pop();
        boardState = JSON.parse(JSON.stringify(next.board));
        turn = next.turn;
        captured = JSON.parse(JSON.stringify(next.captured));
        selected = next.selected ? { ...next.selected } : null;
        kingMoved = JSON.parse(JSON.stringify(next.kingMoved));
        rookMoved = JSON.parse(JSON.stringify(next.rookMoved));
        lastMove = next.lastMove || null;
        enPassantTarget = next.enPassantTarget || null;
        renderCaptured();
        renderBoard();
        gameOverOverlay.style.display = "none";
      }

      document.getElementById("undoBtn").onclick = () => {
        castleSound.currentTime = 0;
        castleSound.play();
        undoMove();
      };
      document.getElementById("redoBtn").onclick = () => {
        castleSound.currentTime = 0;
        castleSound.play();
        redoMove();
      };

      initializeBoard();
    </script>
    <script src="ai.js"></script>
  </body>
</html>
